(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Needs["Statistics`ContinuousDistributions`"];


Needs["Statistics`DiscreteDistributions`"];


Needs["Statistics`NormalDistribution`"];


Needs["MultivariateStatistics`"];


CDF[Frechet[alpha_,beta_],x_]:=Exp[-alpha /x^beta]


PDF[Frechet[alpha_,beta_],x_]:=alpha beta E^(-alpha x^-beta) x^(-1-beta)


Unprotect[Quantile,Random]


Quantile[Frechet[alpha_,beta_],y_]:=(-(alpha/Log[y]))^(1/beta)


Random[Frechet[alpha_,beta_]]:=Quantile[Frechet[alpha,beta],Random[UniformDistribution[0,1]]]


Protect[Quantile,Random]


Off[General::"spell1"]


Dimension[FromDistributionTree[DimensionList_,initialvalue_,OneStepDistributionList_]]:=Dimension[OneStepDistributionList[[1]]]


Dimension[OrthogonalCombineSpaces[SpecList_]]:=Apply[Sum,Map[Dimension,SpecList]]


Dimension[NormalRankCombineSpaces[SpecList_,CorrelationMatrix_]]:=Module[{dim1=Apply[Plus,Map[Dimension,SpecList]]},
If[(dim1==Length[CorrelationMatrix])&&(dim1==Length[CorrelationMatrix[[1]]]),dim1,Print["Dimension[NormalRankCombineSpaces[SpecList,CorrelationMatrix]] : problem in the dimensions"];0]]


Dimension[{a_,b_,c_}]:=Dimension[a]


TimeStepList[FromDistributionTree[DimensionList_,initialvalue_,dlist_]]:=Map[#[[2]]&,dlist]


TimeStepList[OrthogonalCombineSpaces[TreeList_]]:=Module[{consistenceQ,i,tsl1,tsl=Map[TimeStepList,TreeList]},
	If[Length[TreeList]==1,tsl[[1]],
	tsl1=tsl[[1]];
	consistenceQ=Apply[And,Map[(tsl1==#)&,Table[tsl[[i]],{i,2,Length[tsl]}]]];
	If[consistenceQ==True, tsl1,
Print["TimeStepList[OrthogonalCombineSpaces[...]] : different list of stimesteps !"];0]]]


TimeStepList[NormalRankCombineSpaces[TreeList_,CorrelationMatrix_]]:=Module[{consistenceQ,i,tsl1,tsl=Map[TimeStepList,TreeList]},
	If[Length[TreeList]==1,tsl[[1]],
	tsl1=tsl[[1]];
	consistenceQ=Apply[And,Map[(tsl1==#)&,Table[tsl[[i]],{i,2,Length[tsl]}]]];
	If[consistenceQ==True, tsl1,
Print["TimeStepList[OrthogonalCombineSpaces[...]] : different list of stimesteps !"];0]]]


MultiDimensionalTimeSliceTensorialProduct[{x1_,x2_},reducedNodeNumberVector_]:=Module[{i1,i2},
Flatten[Table[MultiDimensionalNodeListTensorialProduct[{x1[[i1]],x2[[i2]]},reducedNodeNumberVector], {i1,1,Length[x1]},{i2,1,Length[x2]}],1]]


MultiDimensionalTimeSliceTensorialProduct[{x1_,x2_,x3_},reducedNodeNumberVector_]:=Module[{i1,i2},
Flatten[Table[MultiDimensionalNodeListTensorialProduct[{x1[[i1]],x2[[i2]],x3[[i3]]},reducedNodeNumberVector], {i1,1,Length[x1]},{i2,1,Length[x2]},{i3,1,Length[x3]}],2]]


MultiDimensionalTimeSliceTensorialProduct[{x1_,x2_},Mcorrelation_,Speclist_,reducedNodeNumberVector_,{antex1_,antex2_}]:=Module[{i1,i2},
Flatten[Table[MultiDimensionalNodeListTensorialProduct[{x1[[i1]],x2[[i2]]},Mcorrelation,Speclist,reducedNodeNumberVector,Join[NodeValue[antex1,x1[[i1,1,4]]],NodeValue[antex2,x2[[i2,1,4]]]]], {i1,1,Length[x1]},{i2,1,Length[x2]}],1]]


MultiDimensionalTimeSliceTensorialProduct[{x1_,x2_,x3_},Mcorrelation_,Speclist_,reducedNodeNumberVector_,{antex1_,antex2_,antex3_}]:=Module[{i1,i2,i3},
Flatten[Table[MultiDimensionalNodeListTensorialProduct[{x1[[i1]],x2[[i2]],x3[[i3]]},Mcorrelation,Speclist,reducedNodeNumberVector,Join[NodeValue[antex1,x1[[i1,1,4]]],NodeValue[antex2,x2[[i2,1,4]]],NodeValue[antex3,x3[[i3,1,4]]]]], {i1,1,Length[x1]},{i2,1,Length[x2]},{i3,1,Length[x3]}],2]]


MultiDimensionalNodeListTensorialProduct[{a_,b_},reducedNodeNumberVector_]:=Module[{i,j},
Flatten[Table[{
NodeName[reducedNodeNumberVector,{a[[i,1]],b[[j,1]]}],
a[[i,2]],
Join[a[[i,3]],b[[j,3]]],
NodeName[reducedNodeNumberVector,{a[[i,4]],b[[j,4]]}]}, {i,1,Length[a]},{j,1,Length[b]}],1]]


MultiDimensionalNodeListTensorialProduct[{x1_,x2_,x3_},reducedNodeNumberVector_]:=Module[{i1,i2,i3},
Flatten[Table[{
NodeName[reducedNodeNumberVector,{x1[[i1,1]],x2[[i2,1]],x3[[i3,1]]}],
x1[[i1,2]],
Join[x1[[i1,3]],x2[[i2,3]],x3[[i3,3]]],
NodeName[reducedNodeNumberVector,{x1[[i1,4]],x2[[i2,4]],x3[[i3,4]]}]
}, {i1,1,Length[x1]},{i2,1,Length[x2]},{i3,1,Length[x3]}],2]]


MultiDimensionalNodeListTensorialProduct[{a_,b_},Mcorrelation_,Speclist_,reducedNodeNumberVector_,{aPrecedingValue_,bPrecedingValue_}]:=Module[{i,j},
Flatten[Table[{
NodeName[reducedNodeNumberVector,{a[[i,1]],b[[j,1]]}],
a[[i,2]],
Module[{Y,ashift=a[[i,3,1]]-aPrecedingValue,bshift=b[[j,3,1]]-bPrecedingValue},Y=Mcorrelation.{ToGaussian[Speclist[[1,1]],ashift][aPrecedingValue],ToGaussian[Speclist[[2,1]],bshift][bPrecedingValue]};
{FromGaussian[Speclist[[1,1]],Y[[1]]][aPrecedingValue]+aPrecedingValue,FromGaussian[Speclist[[2,1]],Y[[2]]][bPrecedingValue]+bPrecedingValue}],
NodeName[reducedNodeNumberVector,{a[[i,4]],b[[j,4]]}]
}, {i,1,Length[a]},{j,1,Length[b]}],1]]


MultiDimensionalNodeListTensorialProduct[{x1_,x2_,x3_},Mcorrelation_,Speclist_,reducedNodeNumberVector_,{x1PrecedingValue_,x2PrecedingValue_,x3PrecedingValue_}]:=Module[{i1,i2,i3},
Flatten[Table[{
NodeName[reducedNodeNumberVector,{x1[[i1,1]],x2[[i2,1]],x3[[i3,1]]}],
x1[[i1,2]],
Module[{Y=Mcorrelation.{ToGaussian[Speclist[[1,1]],x1[[i1,3,1]]-x1PrecedingValue][x1PrecedingValue],ToGaussian[Speclist[[2,1]],x2[[i2,3,1]]-x2PrecedingValue][x2PrecedingValue],ToGaussian[Speclist[[3,1]],x3[[i3,3,1]]-x3PrecedingValue][x3PrecedingValue]}},{FromGaussian[Speclist[[1,1]],Y[[1]]][x1PrecedingValue]+x1PrecedingValue,FromGaussian[Speclist[[2,1]],Y[[2]]][x2PrecedingValue]+x2PrecedingValue,FromGaussian[Speclist[[3,1]],Y[[3]]][x3PrecedingValue]+x3PrecedingValue}],
NodeName[reducedNodeNumberVector,{x1[[i1,4]],x2[[i2,4]],x2[[i2,4]]}]
}, {i1,1,Length[x1]},{i2,1,Length[x2]},{i3,1,Length[x3]}],2]]


NodeName[LengthList_,IndexList_]:=If[Length[LengthList]==0,IndexList[[1]],IndexList[[1]]+LengthList[[1]] NodeName[Rest[LengthList],Rest[IndexList]]];
(* LengthList should have n-1 elements , when IndexList has n elements , the value of Indexlist should between 0 and N-1, N being the corresponding elements of LengthList*)


InverseNodeName[LengthList_,nb_]:=If[Length[LengthList]==0,{nb},Prepend[InverseNodeName[Rest[LengthList],Quotient[nb,LengthList[[1]]]],Mod[nb,LengthList[[1]]]]]


NodeValue[timeslice_,nodename_]:=Select[Flatten[timeslice,1],(#[[1]]==nodename)&][[1,3]]


ConditionalDistribution[LogNormalDistributionD[mean_,sigma_]]:=Function[{x},LogNormalDistribution[mean,sigma]]


Dimension[LogNormalDistributionD[mean_,sigma_]]=1;


ToGaussian[LogNormalDistributionD[mean_,sigma_],x_]:=Function[{z},N[Quantile[NormalDistribution[0,1],CDF[LogNormalDistribution[mean,sigma],x]]]]


FromGaussian[LogNormalDistributionD[mean_,sigma_],x_]:=Function[{z},N[Quantile[LogNormalDistribution[mean,sigma],CDF[NormalDistribution[0,1],x]]]]


ConditionalDistribution[GammaDistributionD[alpha_,lambda_]]:=Function[{x},GammaDistribution[alpha,lambda]]


Dimension[GammaDistributionD[alpha_,lambda_]]=1;


ToGaussian[GammaDistributionD[alpha_,lambda_],x_]:=Function[{z},N[Quantile[NormalDistribution[0,1],CDF[GammaDistribution[alpha,lambda],x]]]]


FromGaussian[GammaDistributionD[alpha_,lambda_],x_]:=Function[{z},N[Quantile[GammaDistribution[alpha,lambda],CDF[NormalDistribution[0,1],x]]]]


ConditionalDistribution[ChiSquareDistributionD[m_]]:=Function[{x},ChiSquareDistribution[m]]


ToGaussian[ChiSquareDistributionD[m_],x_]:=Function[{z},N[Quantile[NormalDistribution[0,1],CDF[ChiSquareDistribution[m],x]]]]


FromGaussian[ChiSquareDistributionD[m_],x_]:=Function[{z},N[Quantile[ChiSquareDistribution[m],CDF[NormalDistribution[0,1],x]]]]


Dimension[ChiSquareDistributionD[m_]]=1;


ConditionalDistribution[ExponentialDistributionD[mean_]]:=Function[{x},ExponentialDistribution[mean]]


ToGaussian[ExponentialDistributionD[mean_],x_]:=Function[{z},N[Quantile[NormalDistribution[0,1],CDF[ExponentialDistribution[mean],x]]]]


FromGaussian[ExponentialDistributionD[mean_],x_]:=Function[{z},N[Quantile[ExponentialDistribution[mean],CDF[NormalDistribution[0,1],x]]]]


Dimension[ExponentialDistributionD[mean_]]=1;


ConditionalDistribution[StudentTDistributionD[m_]]:=Function[{x},StudentTDistribution[m]]


ToGaussian[StudentTDistributionD[m_],x_]:=Function[{z},N[Quantile[NormalDistribution[0,1],CDF[StudentTDistribution[m],x]]]]


FromGaussian[StudentTDistributionD[m_],x_]:=Function[{z},N[Quantile[StudentTDistribution[m],CDF[NormalDistribution[0,1],x]]]]


Dimension[StudentTDistributionD[m_]]=1;


ConditionalDistribution[ExtremeValueDistributionD[alpha_,lambda_]]:=Function[{x},ExtremeValueDistribution[alpha,lambda]]


ToGaussian[ExtremeValueDistributionD[alpha_,lambda_],x_]:=Function[{z},N[Quantile[NormalDistribution[0,1],CDF[ExtremeValueDistribution[alpha,lambda],x]]]]


FromGaussian[ExtremeValueDistributionD[alpha_,lambda_],x_]:=Function[{z},N[Quantile[ExtremeValueDistribution[alpha,lambda],CDF[NormalDistribution[0,1],x]]]]


Dimension[ExtremeValueDistributionD[alpha_,lambda_]]=1;


ConditionalDistribution[ParetoDistributionD[alpha_,lambda_]]:=Function[{x},ParetoDistribution[alpha,lambda]]


ToGaussian[ParetoDistributionD[alpha_,lambda_],x_]:=Function[{z},N[Quantile[NormalDistribution[0,1],CDF[ParetoDistribution[alpha,lambda],x]]]]


FromGaussian[ParetoDistributionD[alpha_,lambda_],x_]:=Function[{z},N[Quantile[ParetoDistribution[alpha,lambda],CDF[NormalDistribution[0,1],x]]]]


Dimension[ParetoDistributionD[alpha_,lambda_]]=1;


ConditionalDistribution[FrechetD[alpha_,lambda_]]:=Function[{x},Frechet[alpha,lambda]]


ToGaussian[FrechetD[alpha_,lambda_],x_]:=Function[{z},N[Quantile[NormalDistribution[0,1],CDF[Frechet[alpha,lambda],x]]]]


FromGaussian[FrechetD[alpha_,lambda_],x_]:=Function[{z},N[Quantile[Frechet[alpha,lambda],CDF[NormalDistribution[0,1],x]]]]


Dimension[FrechetD[alpha_,lambda_]]=1;


ConditionalDistribution[UniformDistributionD[min_,max_]]:=Function[{x},UniformDistribution[min,max]]


ToGaussian[UniformDistributionD[min_,max_],x_]:=Function[{z},N[Quantile[NormalDistribution[0,1],CDF[UniformDistribution[min,max],x]]]]


FromGaussian[UniformDistributionD[min_,max_],x_]:=Function[{z},N[Quantile[UniformDistribution[min,max],CDF[NormalDistribution[0,1],x]]]]


Dimension[UniformDistributionD[min_,max_]]=1;


ConditionalDistribution[NormalDistributionD[mean_,sd_]]:=Function[{x},NormalDistribution[mean,sd]]


ToGaussian[NormalDistributionD[mean_,sd_],x_]:=Function[{z},(x-mean)/sd]


FromGaussian[NormalDistributionD[mean_,sd_],x_]:=Function[{z},mean+sd x]


Dimension[NormalDistributionD[mean_,sd_]]=1;


ConditionalDistribution[MultinormalDistributionD[mean_,Covmatrix_,nbpc_]]:=Function[{x},MultinormalDistribution[mean,Covmatrix,nbpc]]


Dimension[MultinormalDistributionD[mean_,Covmatrix_,nbpc_]]:=If[(Length[mean]==Length[Covmatrix])&&
(Length[mean]==Length[Covmatrix[[1]]]),Length[mean],Print["MultinormalDistributionD : dimension of the mean and the Covmatrix not consistent !"];0]


ConditionalDistribution[LinearDriftNormalDistributionD[a_,b_,sd_]]:=Function[{x},NormalDistribution[a x + b,sd]]


ToGaussian[LinearDriftNormalDistributionD[a_,b_,sd_],x_]:=Function[{z},(x-a z-b)/sd]


FromGaussian[LinearDriftNormalDistributionD[a_,b_,sd_],x_]:=Function[{z},a z + b+sd x]


Dimension[LinearDriftNormalDistributionD[a_,b_,sd_]]=1;


ConditionalDistribution[Schwartz2FactorsDistributionD[kappaChi_,sigmaChi_,muZeta_,sigmaZeta_,rho_,deltaT_]]:=Function[{chi,zeta},MultinormalDistribution[{Exp[-kappaChi deltaT]chi-chi,muZeta deltaT},
{{(1-Exp[-2 kappaChi deltaT])sigmaChi^2/(2kappaChi),(1-Exp[- kappaChi deltaT])sigmaChi sigmaZeta rho/kappaChi},
{(1-Exp[- kappaChi deltaT])sigmaChi sigmaZeta rho/kappaChi,sigmaZeta^2 deltaT}},2]]


Dimension[Schwartz2FactorsDistributionD[kappaChi_,sigmaChi_,muZeta_,sigmaZeta_,rho_,deltaT_]]=2


MCGeneratePath[FromDistributionTree[DimensionList_,x0_,dlist_],t0_]:=Module[{dim,currentnode,nextnode,slicerank,Initialnode,noderank,j,z},
	dim=Length[x0];noderank=0;
	Initialnode={noderank,t0,x0,0};
currentnode=Initialnode;
Table[If[slicerank==0,Initialnode,
nextnode=Module[{
	dist=ConditionalDistribution[dlist[[slicerank]][[1]]][currentnode[[3]]],
	branchingfactor=dlist[[slicerank]][[3]],
	timestep=dlist[[slicerank]][[2]],
         xstart=currentnode[[3]],
         tstart=currentnode[[2]],
	nodestart=currentnode[[1]],j},
	If[dist[[0]]===MultinormalDistribution,
			z=MultiNormalPath[noderank,tstart,timestep,xstart,branchingfactor,nodestart,dist];
			noderank=z[[2]];
			z[[1]],
	noderank=noderank+1;
	If[branchingfactor==1,
		{noderank,tstart+timestep,xstart+{Mean[dist]},nodestart},
		j=Random[DiscreteUniformDistribution[branchingfactor]];
		{noderank,tstart+timestep,xstart+Quantile[dist,(j-1/2)/branchingfactor],nodestart}]]];
currentnode=nextnode;nextnode],
{slicerank,0,Length[dlist]}]
]


MultiNormalPath[noderank0_,tstart_,timestep_,xstart_,branchingfactor_,nodestart_,dist_]:=Module[{mean=dist[[1]],covariancematrix=dist[[2]],nbpc=dist[[3]],vecs,vals,noderank,k,j,result},
{vals,vecs}=Eigensystem[covariancematrix];
noderank=noderank0;
j=Array[0&,nbpc];
noderank=noderank+1;
result=If[branchingfactor==1,
	{noderank,tstart+timestep,xstart+mean,nodestart},
	{noderank,tstart+timestep,
Do[j[[k]]=Random[DiscreteUniformDistribution[branchingfactor]],{k,1,nbpc}];
Print["j=",j];
xstart+mean+Sum[Sqrt[vals[[k]] ]vecs[[k]]Quantile[NormalDistribution[0,1],
			(j[[k]]-1/2)/branchingfactor],{k,1,nbpc}],nodestart}];
{result,noderank}]



GenerateTree[FromDistributionTree[DimensionList_,x0_,dlist_],t0_]:=Module[{dim,currentnodesslice,nextnodeslice,slicerank,Initialnode,noderank,j,z},
	dim=Length[x0];noderank=0;
	Initialnode={{noderank,t0,x0,0}};
currentnodesslice=Initialnode;
(* Print["initialnode=",Initialnode];*)
Table[If[slicerank==0,{Initialnode},
nextnodeslice=Map[(Module[{
	dist=Apply[ConditionalDistribution[dlist[[slicerank]][[1]]],#[[3]]],
	branchingfactor=dlist[[slicerank]][[3]],
	timestep=dlist[[slicerank]][[2]],
         xstart=#[[3]],
         tstart=#[[2]],
	nodestart=#[[1]],j},
	If[dist[[0]]===MultinormalDistribution,z=MultiNormalBranching[noderank,tstart,timestep,xstart,branchingfactor,nodestart,dist];
		noderank=z[[2]];z[[1]],
Table[noderank=noderank+1;If[branchingfactor==1,
	{noderank,tstart+timestep,xstart+{Mean[dist]},nodestart},
	{noderank,tstart+timestep,xstart+{Quantile[dist,(j-1/2)/branchingfactor]},nodestart}]
,{j,1,branchingfactor}]]])&,currentnodesslice];
(* Print["nextnodeslice=",nextnodeslice]; *)
currentnodesslice=Apply[Join,nextnodeslice];nextnodeslice],
{slicerank,0,Length[dlist]}]
]


MultiNormalBranching[noderank0_,tstart_,timestep_,xstart_,branchingfactor_,nodestart_,dist_]:=Module[{mean=dist[[1]],covariancematrix=dist[[2]],nbpc=dist[[3]],vecs,vals,noderank,k,j1,j2,j3,j4,j,j5,result},
{vals,vecs}=Eigensystem[covariancematrix];
noderank=noderank0;
result=Which[nbpc==1,Table[noderank=noderank+1;If[branchingfactor==1,
	{noderank,tstart+timestep,xstart+mean,nodestart},
	{noderank,tstart+timestep,xstart+mean+Sqrt[Abs[vals[[1]]] ]Re[vecs[[1]]]Quantile[NormalDistribution[0,1],(j1-1/2)/branchingfactor],nodestart}],
			{j1,1,branchingfactor}],
	nbpc==2,Flatten[Table[noderank=noderank+1;If[branchingfactor==1,
	{noderank,tstart+timestep,xstart+mean,nodestart},
	{noderank,tstart+timestep,
(*Print["xstart=",xstart];
Print["mean=",mean];
Print["s=",Sum[Sqrt[Abs[vals[[k]]] ]Re[vecs[[k]]]Quantile[NormalDistribution[0,1],(Switch[k,1,j1,2,j2,3,j3]-1/2)/branchingfactor],{k,1,nbpc}]];
*)
xstart+mean+Sum[Sqrt[Abs[vals[[k]] ]]Re[vecs[[k]]]Quantile[NormalDistribution[0,1],(Switch[k,1,j1,2,j2,3,j3]-1/2)/branchingfactor],{k,1,nbpc}],nodestart}],
			{j1,1,branchingfactor},{j2,1,branchingfactor}],1],
nbpc==3,Flatten[Table[noderank=noderank+1;If[branchingfactor==1,
	{noderank,tstart+timestep,{xstart+mean},nodestart},
	{noderank,tstart+timestep,{xstart+mean+Sum[Sqrt[Abs[vals[[k]] ]]Re[vecs[[k]]]Quantile[NormalDistribution[0,1],(Switch[k,1,j1,2,j2,3,j3]-1/2)/branchingfactor],{k,1,nbpc}]},nodestart}],
			{j1,1,branchingfactor},{j2,1,branchingfactor},{j3,1,branchingfactor}],2],
nbpc>3,Print["branching greater than 3 not implemented"]
];
{result,noderank}]



GenerateTree[OrthogonalCombineSpaces[SpecList_],t0_]:=Module[{i,ioperand,jdate,NodeNumberVector,reducedNodeNumberVector,result,Treelist,tsl=TimeStepList[OrthogonalCombineSpaces[SpecList]]},
Treelist=Table[GenerateTree[SpecList[[i]],t0],{i,1,Length[SpecList]}];
NodeNumberVector=Table[Length[Flatten[Treelist[[i]],2]],{i,1,Length[SpecList]}];
reducedNodeNumberVector=Drop[NodeNumberVector,-1];
result=
Table[MultiDimensionalTimeSliceTensorialProduct[Table[Treelist[[ioperand,jdate]],{ioperand,1,Length[Treelist]}],reducedNodeNumberVector],
{jdate,1,Length[tsl]+1}];
NodeNameTable=Map[(#[[1]])&,Flatten[result,2]];
Map[(Map[Map[Function[{x},{Position[NodeNameTable,x[[1]]][[1,1]]-1,x[[2]],x[[3]],Position[NodeNameTable,x[[4]]][[1,1]]-1}],#]&,#])&,result]
]


MCGeneratePath[OrthogonalCombineSpaces[SpecList_],t0_]:=Module[{i,ioperand,jdate,NodeNumberVector,reducedNodeNumberVector,result,Treelist,tsl=TimeStepList[OrthogonalCombineSpaces[SpecList]]},
Treelist=Table[MCGeneratePath[SpecList[[i]],t0],{i,1,Length[SpecList]}];
Table[{Treelist[[1,j,1]],Treelist[[1,j,2]],Apply[Join,Table[Treelist[[k,j,3]],{k,1,Length[SpecList]}]],Treelist[[1,j,4]]},{j,1,Length[Treelist[[1]]]}]
]


GenerateTree[NormalRankCombineSpaces[SpecList_,CorrelationMatrix_],t0_]:=Module[{i,ioperand,reducedNodeNumberVector,NodeNumberVector,Mcorrelation,jdate,dim1,result,Treelist0,tsl=TimeStepList[NormalRankCombineSpaces[SpecList,CorrelationMatrix]]},
dim1=Dimension[NormalRankCombineSpaces[SpecList,CorrelationMatrix]];
Treelist=Table[GenerateTree[SpecList[[i]],t0],{i,1,Length[SpecList]}];
NodeNumberVector=Table[Length[Flatten[Treelist[[i]],2]],{i,1,Length[SpecList]}];
reducedNodeNumberVector=Drop[NodeNumberVector,-1];
Mcorrelation=CholeskyDecomposition[CorrelationMatrix];
(* Print["Treelist=",Treelist];
Print["reducedNodeNumberVector=",reducedNodeNumberVector];
Print["tsl=",tsl];
Print["dim1=",dim1];  *)
result=Table[If[jdate==1,
MultiDimensionalTimeSliceTensorialProduct[Table[Treelist[[ioperand,jdate]],{ioperand,1,Length[Treelist]}],reducedNodeNumberVector],MultiDimensionalTimeSliceTensorialProduct[Table[Treelist[[ioperand,jdate]],{ioperand,1,Length[Treelist]}],Mcorrelation,Table[SpecList[[ioperand,3,jdate-1]],{ioperand,1,Length[SpecList]}],reducedNodeNumberVector,Table[Treelist[[ioperand,jdate-1]],{ioperand,1,Length[Treelist]}]]],
{jdate,1,Length[tsl]+1}];
NodeNameTable=Map[(#[[1]])&,Flatten[result,2]];
(* Print["NodeNameTable=",NodeNameTable];
Print["result=",result]; *)
Map[(Map[Map[Function[{x},{Position[NodeNameTable,x[[1]]][[1,1]]-1,x[[2]],x[[3]],Position[NodeNameTable,x[[4]]][[1,1]]-1}],#]&,#])&,result]
]


MCGeneratePath[NormalRankCombineSpaces[SpecList_,CorrelationMatrix_],t0_]:=Module[{i,ioperand,jdate,NodeNumberVector,reducedNodeNumberVector,result,Treelist,tsl=TimeStepList[OrthogonalCombineSpaces[SpecList]]},
Treelist=Table[MCGeneratePath[SpecList[[i]],t0],{i,1,Length[SpecList]}];
Mcorrelation=CholeskyDecomposition[CorrelationMatrix];
Table[{Treelist[[1,j,1]],Treelist[[1,j,2]],If[j==1,Apply[Join,Table[Treelist[[k,j,3]],{k,1,Length[SpecList]}]],
Module[{Y=Mcorrelation.Table[ToGaussian[SpecList[[k,3,j-1,1]],Treelist[[k,j,3,1]]-Treelist[[k,j-1,3,1]]][Treelist[[k,j-1,3,1]]],{k,1,Length[SpecList]}]},
Table[FromGaussian[SpecList[[k,3,j-1,1]],Y[[k]]][Treelist[[k,j-1,3,1]]]+Treelist[[k,j-1,3,1]],{k,1,Length[SpecList]}]]
],Treelist[[1,j,4]]},{j,1,Length[Treelist[[1]]]}]
]


CompileProcess[FromProcessTree[DimensionList_,Process_,TimeStepsList_, branchingfactorlist_,x0_]]:=Module[{nb=Length[TimeStepsList],i,DistList},
DistList=Table[{ProcessToDistribution[Process][TimeStepsList[[i]]],TimeStepsList[[i]],branchingfactorlist[[i]]},{i,1,nb}];
FromDistributionTree[DimensionList,x0,DistList]]


On[General::"spell1"]


ProcessToDistribution[NormalProcess[mean_,sdev_]]:=Function[x,NormalDistributionD[mean x,sdev Sqrt[Abs[x]]]]


ProcessToDistribution[MultiNormalProcess[mean_,cov_,nbpc_]]:=Function[x,MultinormalDistributionD[mean x,cov  Abs[x],nbpc]]


ProcessToDistribution[LogNormalProcess[logmean_,logsdev_]]:=Function[{x},LogNormalDistributionD[logmean x,logsdev Sqrt[Abs[x]]]]


ProcessToDistribution[MeanRevertingProcess[longtermlimit_,revertingspeed_, localsdev_]]:=Function[{x},LinearDriftNormalDistributionD[-(1-Exp[-revertingspeed x]),longtermlimit (1-Exp[-revertingspeed x]),localsdev Sqrt[(1-Exp[-2revertingspeed x])/(2 revertingspeed)]]]


ProcessToDistribution[Schwartz2FactorsProcess[kappaChi_,sigmaChi_,MuZeta_,SigmaZeta_,rho_,deltaT_]]:=
Function[{x},Schwartz2FactorsDistributionD[kappaChi,sigmaChi,MuZeta,SigmaZeta,rho,deltaT]]



